#!/usr/bin/env python3

"""A module to build, configure, and run NILRT build containers.

This module contains a CLI application and backing logic to:
(a) build NILRT-building docker containers from a Dockerfile
(b) process the contents of nilrt-container.conf files
(c) standup a NILRT-build-environment using the users' configuration
(d) dynamically enter that environment and provide the user with a viable,
    interactive shell

Module Usage:
    *See CLI section below*
"""

from pathlib import Path
from pprint import pprint, pformat
import logging
import os
import shutil
import sys
import yaml

import docker
import dockerpty
from docker.types import Mount

# setup module logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


DIR_SS_BUILD_ENV = '/etc/init.build-env.d'
DIR_SS_CONTAINER = '/etc/init.container.d'
P4_CONFIG_FILE = '.p4config'


class NILRTContainerConfig(dict):
    """Parses and stores configuration values for the NILRTContainer class.

    This class inherits from dict and stores configuration values within its
    internal dictionary.

    Attributes:
        DEFAULTS: dict of default values for NILRTContainer configuration values

    Public Dictionary Keys:
        'config_file': pathlib.Path to the external configuration file, from
            which this object was created
        'config_root': an absolute pathlib.Path to the parent directory of
            'config_file'
    """

    DEFAULTS = {
        'workspace' : {
            'username': 'builder',
            'uid': os.geteuid(),
            'gid': os.getegid()
        },
        'p4-setup': {},
        'git-setup': {},
        'bind-mounts': {},
        'env': {},
        'build-env-scripts': [],
        'container-start-scripts': [],
        'image': {
            'name': 'nilrt-build',
            'tag' : 'latest',
            'Dockerfile': '../Dockerfile'
        }
    }


    class ScriptIndex():
        """Utility class for generating a sequence of runparts numeric prefixes.

        This utility class generates a stepped sequence of numeric prefixes,
        which evenly distribute values between index_min and index_max. These
        prefixes are useful to generate runparts directories.

        This class implements the Iterator protocol.

        Attributes:
            index_min: An integer, which is the minimum prefix value (incl.)
            index_max: An integer, which is the maximum prefix value (incl.)
            step: An integer distance, by which the generator steps between
                index_min and index_max.
            location: The current sequence value.
        """

        def __init__(self, index_min=10, index_max=98, step=None):
            if step is None:
                step = 1
            self.index_min = index_min
            self.index_max = index_max
            self.step = step
            self.location = index_min

        def __next__(self):
            if self.location > self.index_max:
                raise StopIteration
            else:
                self.location += self.step
                return self.location

        def __str__(self):
            return '%02d' % self.location

    def __init__(self, config_path=None):
        super().__init__()  # init dict

        if config_path is None:
            config_path = Path(__file__).parent / 'nilrt-container.conf'

        self['config_file'] = config_path
        self['config_root'] = config_path.parent.resolve()
        self._script_indexes = {}
        self._start_scripts = {}
        self._container_ssh_key = None
        self._nilrt_workspace = None

        logger.info('Parsing config file %s' % config_path)

        with open(self['config_file'], 'r') as fp_config:
            config_data = yaml.safe_load(fp_config)

        self.update(config_data['config'])

        self.__init_start_scripts()
        self.__init_bind_mounts()
        self.__init_env_variables()
        self.__init_p4_setup()
        self.__init_git_setup()
        self.__init_workspace()
        logger.debug(pformat(self, indent=4))

    def __get_validate_path(self, path):
        full_path = Path(path)
        # relative paths are based from the location of the conf file, or CWD
        if not full_path.is_absolute():
            full_path = self['config_root'] / full_path
        logger.debug('full_path = %s' % full_path.resolve())

        if not full_path.exists():
            raise ValueError('File "%s" does not exist.' % full_path)

        return full_path

    def __init_start_scripts(self):
        def __extract_scripts(conf_key, container_path):
            for script in self.get_or_default(conf_key):
                script_path = self.__get_validate_path(script)
                self.add_start_script(script_path, container_path)

        self._start_scripts[DIR_SS_BUILD_ENV] = []
        __extract_scripts('build-env-scripts', DIR_SS_BUILD_ENV)
        self._start_scripts[DIR_SS_CONTAINER] = []
        __extract_scripts('container-start-scripts', DIR_SS_CONTAINER)

    def add_start_script(self, host_path, container_path):
        host_path = Path(host_path).expanduser().resolve()
        if not host_path.is_file():
            raise ValueError('Requested start script "%s" is not a file on '
                             'host.' % host_path)
        index = self._script_indexes.get(
            container_path,
            NILRTContainerConfig.ScriptIndex(index_min=25, index_max=75))
        self._start_scripts[container_path].append(Mount(
            '%s/%s-%s' % (container_path, str(index), host_path.name),
            '%s' % host_path,
            type='bind', read_only=False))

    def __init_bind_mounts(self):
        self._bind_mounts = []
        for key, value in self.get_or_default('bind-mounts').items():
            self._bind_mounts.append(Mount(value['dest'], value['src'],
                                           type='bind',
                                           read_only=bool(value['read-only'])))
            if key == 'ssh-key':
                self._container_ssh_key = value['dest']

    def __init_p4_setup(self):
        p4_setup = self.get_or_default('p4-setup')
        p4_user = p4_setup['user']
        p4_servers = p4_setup['servers']
        staging_directory = 'staging'
        env = {}
        try:
            shutil.rmtree(staging_directory)
        except FileNotFoundError:
            pass
        os.mkdir(staging_directory)
        for server, config in p4_servers.items():
            filename = os.path.join(staging_directory, server + '.config')
            entry = '{}={}\n'
            with open(filename, 'w') as filep:
                filep.write('workspace_root ' + \
                    os.path.join(config['p4root'], P4_CONFIG_FILE) + \
                    '\n')
                filep.write(entry.format('P4CLIENT', config['clientspec']))
                filep.write(entry.format('P4USER', p4_user))
                filep.write(entry.format('P4PORT', config['p4port']))
            nibuild_string = 'nibuild_{}_{}'
            for key, value in config.items():
                env[nibuild_string.format(server, key)] = value
            env['P4CONFIG'] = P4_CONFIG_FILE
        env['P4TICKETS'] = p4_setup['p4tickets']
        self._env_variables.update(env)

    def __init_git_setup(self):
        git_setup = self.get_or_default('git-setup')
        env = {}
        env['NILRT_REMOTE'] = git_setup['remote']
        env['NILRT_ROOT'] = git_setup['root']
        self._nilrt_workspace = git_setup['root']
        env['NILRT_BRANCH'] = git_setup['branch']
        self._env_variables.update(env)

    def __init_env_variables(self):
        self._env_variables = self.get_or_default('env')

    def __init_workspace(self):
        # TODO(sravicha): The following is a last minute messy codepath to
        # workaround get_or_default('workspace') not filling up only those
        # keys that are missing.
        # For example, if only 'username' key is provided,
        # get_or_default('workspace') will return {'username': 'abc'}. It does
        # not auto-fill the remaining missing keys.
        workspace = {}
        workspace['uid'] = self.get_or_default('workspace', 'uid')
        workspace['gid'] = self.get_or_default('workspace', 'gid')
        workspace['username'] = self.get_or_default('workspace', 'username')
        if self.get('workspace'):
            self['workspace'].update(workspace)
        else:
            self['workspace'] = workspace

    @property
    def env_variables(self):
        return self._env_variables

    @property
    def bind_mounts(self):
        return self._bind_mounts

    @property
    def ssh_key_location(self):
        return self._container_ssh_key

    @property
    def nilrt_workspace(self):
        return self._nilrt_workspace

    @property
    def workspace(self):
        return self['workspace']

    @property
    def dockerfile_path(self):
        return self.__get_validate_path(self.get_or_default('image',
                                                            'Dockerfile'))

    @property
    def start_scripts(self):
        return self.container_start_scripts + self.build_env_start_scripts

    @property
    def build_env_start_scripts(self):
        return self._start_scripts.get(DIR_SS_BUILD_ENV, list())

    @property
    def container_start_scripts(self):
        return self._start_scripts.get(DIR_SS_CONTAINER, list())

    @property
    def image_tag(self):
        name = self.get_or_default('image', 'name')
        tag = self.get_or_default('image', 'tag')
        return ':'.join([name, tag])

    def get_or_default(self, *keys):
        return self._get_or_default(self, self.DEFAULTS, *keys)

    @staticmethod
    def _get_or_default(dict_tree, defaults, *args):
        if len(args) == 0:
            raise ValueError('args cannot be length 0')
        args = list(args)
        key = args.pop(0)

        try:
            dict_tree_sub = dict_tree.get(key, None)
        except TypeError:
            return dict_tree
        except AttributeError:
            dict_tree_sub = None

        try:
            defaults_sub = defaults.get(key)
        except (AttributeError, TypeError):
            if dict_tree is None:
                return defaults_sub
        except KeyError:
            raise KeyError('No default value found.')

        if len(args) == 0:
            return dict_tree_sub or defaults_sub
        else:
            return NILRTContainerConfig._get_or_default(
                dict_tree_sub, defaults_sub, *args)


class NILRTContainer():
    def __init__(self):
        self.client = docker.APIClient(base_url='unix://var/run/docker.sock')
        logger.debug(pformat(self.client.info()))
        self.environment = {}

    def _create_host_config(self, mounts):
        binds = {}
        for mount in mounts:
            pprint(mount)
            binds[mount['Source']] = {
                'bind': mount['Target'],
                'type': mount['Type'],
                'read_only': 'ro' if mount.get('Read_only', None) else 'rw',
            }


        return self.client.create_host_config(binds=binds)

    def build(self, image_tag, dockerfile_path, no_cache=False):
        workspace=os.path.dirname(dockerfile_path.resolve())
        output_iterator = self.client.build(
            path=str(workspace),
            dockerfile=str(dockerfile_path),
            nocache=no_cache,
            tag=image_tag,
            rm=True,
            decode=True)
        for line in output_iterator:
            if 'stream' in line:
                print(line['stream'], end='')
            # Docker throws an error the first time the error happens, and then
            # caches the value and only prints the error, not throw (WEIRD?).
            elif 'error' in line:
                raise Exception(line['error'])

    def start(self, image_tag, mounts=[], environment={}):
        run_args = ['-i', '-v']  # interactive and verbose

        host_config = self._create_host_config(mounts)

        run_env = self.environment
        run_env.update(environment)

        container = self.client.create_container(
            environment=run_env,
            host_config=host_config,
            image=image_tag,
            stdin_open=True,
            tty=True,
            volumes=[mount['Target'] for mount in mounts],
            )

        dockerpty.start(self.client, container)


## CLI ##
#########


def cmd_build(args, config):
    if args.prune:
        docker_client.prune_containers()
        docker_client.prune_images()
        try:
            docker_client.remove_image(config.image_tag)
        except docker.errors.ImageNotFound:
            pass
        args.no_cache = True

    if not os.path.exists(args.dockerfile):
        raise ValueError('Found no NILRT dockerfile at %s' % \
            args.dockerfile.resolve())

    container = NILRTContainer()
    container.build(config.image_tag, args.dockerfile, args.no_cache)


def cmd_start(args, config):
    if not config.nilrt_workspace:
        raise Exception('Provide nilrt workspace bind mnt directory in .conf'\
                        'file.')

    # setup container config & mounts
    container = NILRTContainer()
    mounts = config.start_scripts + config.bind_mounts
    container.environment.update(config.env_variables)
    logger.debug(pformat(mounts, indent=4))

    container.environment['NILRT_UID'] = config.workspace['uid']
    container.environment['NILRT_GID'] = config.workspace['gid']
    container.environment['NILRT_USERNAME'] = config.workspace['username']
    if config.ssh_key_location:
        container.environment['NILRT_SSH_KEY'] = config.ssh_key_location
    if args.container_name is not None:
        container.environment['NILRT_CONTAINER_NAME'] = args.container_name
    if args.machine is not None:
        container.environment['NILRT_MACHINE'] = args.machine

    logger.info('Starting image %s with uid/gid=%d/%d' %
                (config.image_tag, config.workspace['uid'],
                 config.workspace['gid']))
    container.start(config.image_tag,
                    mounts=mounts)


if __name__ == "__main__":
    from argparse import ArgumentParser
    parser = ArgumentParser()
    subparsers = parser.add_subparsers(title='commands', dest='command')

    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('-n', '--container-name', type=str, default=None)
    parser.add_argument('-v', '--verbose', action='store_true')

    # command: build
    parser_build = subparsers.add_parser('build')
    parser_build.set_defaults(func=cmd_build)
    parser_build.add_argument('-p', '--prune', action='store_true',
        help='Delete existing unused containers, images and the image '\
             'specified in the .conf file (if it already exists)')
    parser_build.add_argument('--no-cache', action='store_true',
        help='Do not use cache when building the image.')
    parser_build.add_argument('dockerfile', type=Path, nargs='?',
        default='Dockerfile.nilrt',
        help='Path to the NILRT Dockerfile which should be used to build this '\
             'image.')

    # command: start
    parser_start = subparsers.add_parser('start')
    parser_start.set_defaults(func=cmd_start)
    parser_start.add_argument('-m', '--machine', type=str, default=None)

    cli_args = parser.parse_args()

    # configure a logging StreamHandler for interactive use
    sh = logging.StreamHandler()
    if cli_args.debug:
        log_level = logging.DEBUG
        log_fmt = '%(levelname)s:%(name)s: %(message)s'
    elif cli_args.verbose:
        log_level = logging.INFO
        log_fmt = '%(levelname)s: %(message)s'
    else:
        log_level = logging.WARNING
        log_fmt = '%(levelname)s: %(message)s'
    sh.setLevel(log_level)
    sh.setFormatter(logging.Formatter(log_fmt))
    logger.addHandler(sh)

    logger.debug(pformat(cli_args))
    if cli_args.command is None:
        parser.print_help()
        sys.exit(2)

    cli_args.func(cli_args, NILRTContainerConfig())
